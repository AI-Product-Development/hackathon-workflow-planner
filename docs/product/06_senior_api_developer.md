# API Design Specification

## 1. API Overview:
This document specifies the design of the backend API for the natural language workflow creation tool prototype, built using FastAPI, SQLModel, and SQLite. The API provides endpoints for user authentication, workflow management, natural language parsing, workflow execution, integration management, and testing. The design adheres to RESTful principles where applicable and focuses on providing a clear and efficient interface for the frontend and potential future clients.

**OpenAPI/Swagger Documentation:** Will be automatically generated by FastAPI and available at `/docs` once the application is running.

## 2. Project Structure:
A potential project structure for the FastAPI application:

```
.
├── main.py             # FastAPI application entry point
├── app/
│   ├── __init__.py
│   ├── core/           # Core configurations, middleware, dependencies
│   │   ├── config.py
│   │   ├── security.py # JWT handling
│   │   └── dependencies.py # DB session, auth dependency
│   ├── db/             # Database setup and engine
│   │   └── database.py # SQLModel engine, session creation
│   ├── models/         # SQLModel database models
│   │   └── models.py   # Based on Data Architect's schema
│   ├── schemas/        # Pydantic models for request/response
│   │   ├── user.py
│   │   ├── workflow.py
│   │   ├── integration.py
│   │   └── workflow_run.py
│   ├── api/            # API routers
│   │   ├── __init__.py # Include all routers
│   │   ├── endpoints/
│   │   │   ├── auth.py
│   │   │   ├── users.py
│   │   │   ├── workflows.py
│   │   │   ├── integrations.py
│   │   │   └── testing.py # Includes parsing and execution endpoints
│   ├── services/       # Business logic and database interactions
│   │   ├── user_service.py
│   │   ├── workflow_service.py
│   │   └── integration_service.py
│   └── exceptions/     # Custom exception definitions
│       └── exceptions.py
└── requirements.txt    # Project dependencies
```

## 3. Core Dependencies:
*   `fastapi`: The web framework.
*   `uvicorn`: ASGI server to run the FastAPI application.
*   `sqlmodel`: Library for interacting with the database, combining Pydantic and SQLAlchemy.
*   `sqlite+aiosqlite`: Asynchronous database driver for SQLite.
*   `pydantic`: For data validation and serialization (integrated with FastAPI and SQLModel).
*   `python-jose[cryptography]`: For JWT encoding and decoding.
*   `passlib[bcrypt]`: For password hashing.
*   `python-multipart`: For form data parsing (if needed).

## 4. Authentication & Authorization:
**Implementation Approach:** OAuth2PasswordBearer will be used with JWT tokens.
- Users will send credentials to `/auth/token` to receive a JWT.
- The JWT will be included in the `Authorization` header as a Bearer token for protected endpoints.
- A dependency function (`get_current_user`) will be used to extract and validate the token, returning the authenticated `User` object (or raising HTTPException).
**Role/Permission Checking:** For the prototype, authorization will primarily involve checking if a user is authenticated (`get_current_user`). Role-based access control (RBAC) can be implemented later by adding a `role` field to the `User` model and adding checks within endpoint logic or dependencies.

## 5. Pydantic & SQLModel Models:
**SQLModel Models:** The SQLModel definitions provided by the Data Architect in `docs/product/05_data_architect.md` will be used directly in the `app/models/models.py` file. These models define the database schema and provide ORM capabilities.

**Pydantic Models:** Separate Pydantic models will be defined in `app/schemas/` for API request and response bodies. These models ensure data validation on input and control the structure and content of output. They will often mirror the SQLModel definitions but may exclude sensitive fields (like `hashed_password` in responses) or include additional fields not stored in the database.

*   `UserCreate`: Pydantic model for user registration request body.
*   `UserResponse`: Pydantic model for user response body (excluding sensitive data).
*   `Token`: Pydantic model for the JWT token response.
*   `WorkflowCreate`: Pydantic model for creating a new workflow.
*   `WorkflowUpdate`: Pydantic model for updating an existing workflow.
*   `WorkflowResponse`: Pydantic model for workflow response body.
*   `IntegrationCreate`: Pydantic model for adding a new integration.
*   `IntegrationResponse`: Pydantic model for integration response body.
*   `WorkflowRunResponse`: Pydantic model for workflow run log response body.
*   `ParseRequest`: Pydantic model for the natural language parsing request.
*   `ParseResponse`: Pydantic model for the parsing result.
*   `ExecuteRequest`: Pydantic model for triggering workflow execution.
*   `TestRequest`, `TestResponse`: Pydantic models for the testing endpoint.

## 6. API Endpoints:

### Authentication API (`app/api/endpoints/auth.py`)
*   `POST /auth/register/`
    *   `Description`: Register a new user.
    *   `Request Body`: `UserCreate`
    *   `Response(s)`: `201 Created` with `UserResponse`
    *   `Auth`: No
*   `POST /auth/token/`
    *   `Description`: Obtain JWT token for authentication.
    *   `Request Body`: OAuth2PasswordRequestForm (FastAPI's built-in form data model)
    *   `Response(s)`: `200 OK` with `Token`
    *   `Auth`: No
*   `GET /auth/me/`
    *   `Description`: Get current authenticated user's details.
    *   `Request Body`: None
    *   `Response(s)`: `200 OK` with `UserResponse`
    *   `Auth`: Yes

### Users API (`app/api/endpoints/users.py`)
*   `GET /users/{user_id}/`
    *   `Description`: Get user details by ID.
    *   `Path Parameters`: `user_id` (int)
    *   `Request Body`: None
    *   `Response(s)`: `200 OK` with `UserResponse`, `404 Not Found`
    *   `Auth`: Yes (potentially add authorization to only allow getting own user or by admin)

### Workflows API (`app/api/endpoints/workflows.py`)
*   `POST /workflows/`
    *   `Description`: Create a new workflow for the authenticated user.
    *   `Request Body`: `WorkflowCreate`
    *   `Response(s)`: `201 Created` with `WorkflowResponse`, `401 Unauthorized`, `422 Unprocessable Entity`
    *   `Auth`: Yes
*   `GET /workflows/`
    *   `Description`: Get all workflows for the authenticated user.
    *   `Request Body`: None
    *   `Response(s)`: `200 OK` with `List[WorkflowResponse]`, `401 Unauthorized`
    *   `Auth`: Yes
*   `GET /workflows/{workflow_id}/`
    *   `Description`: Get a specific workflow by ID for the authenticated user.
    *   `Path Parameters`: `workflow_id` (int)
    *   `Request Body`: None
    *   `Response(s)`: `200 OK` with `WorkflowResponse`, `401 Unauthorized`, `404 Not Found`
    *   `Auth`: Yes
*   `PUT /workflows/{workflow_id}/`
    *   `Description`: Update a specific workflow by ID for the authenticated user.
    *   `Path Parameters`: `workflow_id` (int)
    *   `Request Body`: `WorkflowUpdate`
    *   `Response(s)`: `200 OK` with `WorkflowResponse`, `401 Unauthorized`, `404 Not Found`, `422 Unprocessable Entity`
    *   `Auth`: Yes
*   `DELETE /workflows/{workflow_id}/`
    *   `Description`: Delete a specific workflow by ID for the authenticated user.
    *   `Path Parameters`: `workflow_id` (int)
    *   `Request Body`: None
    *   `Response(s)`: `200 OK` (or 204 No Content), `401 Unauthorized`, `404 Not Found`
    *   `Auth`: Yes
*   `GET /workflows/{workflow_id}/runs/`
    *   `Description`: Get execution logs for a specific workflow.
    *   `Path Parameters`: `workflow_id` (int)
    *   `Request Body`: None
    *   `Response(s)`: `200 OK` with `List[WorkflowRunResponse]`, `401 Unauthorized`, `404 Not Found`
    *   `Auth`: Yes

### Integrations API (`app/api/endpoints/integrations.py`)
*   `POST /integrations/`
    *   `Description`: Add a new integration for the authenticated user.
    *   `Request Body`: `IntegrationCreate`
    *   `Response(s)`: `201 Created` with `IntegrationResponse`, `401 Unauthorized`, `422 Unprocessable Entity`
    *   `Auth`: Yes
*   `GET /integrations/`
    *   `Description`: Get all integrations for the authenticated user.
    *   `Request Body`: None
    *   `Response(s)`: `200 OK` with `List[IntegrationResponse]`, `401 Unauthorized`
    *   `Auth`: Yes
*   `DELETE /integrations/{integration_id}/`
    *   `Description`: Remove an integration by ID for the authenticated user.
    *   `Path Parameters`: `integration_id` (int)
    *   `Request Body`: None
    *   `Response(s)`: `200 OK` (or 204 No Content), `401 Unauthorized`, `404 Not Found`
    *   `Auth`: Yes

### Testing API (`app/api/endpoints/testing.py`)
*   `POST /test/parse/`
    *   `Description`: Test natural language parsing without creating a workflow.
    *   `Request Body`: `ParseRequest`
    *   `Response(s)`: `200 OK` with `ParseResponse`, `422 Unprocessable Entity`
    *   `Auth`: Yes
*   `POST /test/execute/{workflow_id}/`
    *   `Description`: Test execution of a specific workflow with sample data in sandbox mode.
    *   `Path Parameters`: `workflow_id` (int)
    *   `Request Body`: `ExecuteRequest` (containing sample trigger data)
    *   `Response(s)`: `200 OK` with `WorkflowRunResponse` (simulated result), `401 Unauthorized`, `404 Not Found`, `422 Unprocessable Entity`
    *   `Auth`: Yes

## 7. Error Handling Strategy:
FastAPI's HTTPException will be used for standard HTTP errors (400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 422 Unprocessable Entity due to Pydantic validation errors). Custom exception handlers will be implemented for specific application errors (e.g., `WorkflowNotFound`, `IntegrationError`) to return consistent JSON responses with appropriate status codes and error details. A generic 500 Internal Server Error handler will catch unexpected errors.

## 8. Key Asynchronous Operations:
Database operations using SQLModel with `aiosqlite` will be asynchronous. All API endpoints that interact with the database will be defined using `async def`. This allows the application to handle multiple requests concurrently while waiting for database operations to complete, improving performance and scalability compared to blocking database drivers. Other I/O bound operations, such as making requests to MCP servers, will also be asynchronous.
